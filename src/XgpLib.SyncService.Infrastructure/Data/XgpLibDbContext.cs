using Microsoft.EntityFrameworkCore;
using System.Reflection;

namespace XgpLib.SyncService.Infrastructure.Data;

/// <summary>
/// 
/// </summary>
/// <param name="options"></param>
public class XgpLibDbContext(DbContextOptions<XgpLibDbContext> options) : DbContext(options)
{
    /// <summary>
    /// Gets or sets the Genres DbSet for accessing Genre entities in the database.
    /// </summary>
    public DbSet<Genre> Genres { get; set; }

    /// <summary>
    /// Gets or sets the collection of games in the database context.
    /// </summary>
    public DbSet<Game> Games { get; set; }

    /// <summary>
    /// Configures the model for the database context by defining entity properties and relationships.
    /// </summary>
    /// <remarks>This method is called during the model creation process to customize the entity framework
    /// model. In this implementation, the <c>Id</c> property for the <see cref="Game"/> and <see cref="Genre"/>
    /// entities  is configured to not have values generated by the database.</remarks>
    /// <param name="modelBuilder">The <see cref="ModelBuilder"/> used to configure the entity mappings.</param>
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<Game>()
            .Property(g => g.Id)
            .ValueGeneratedNever();

        modelBuilder.Entity<Genre>()
            .Property(g => g.Id)
            .ValueGeneratedNever();
    }

    /// <summary>
    /// Saves all changes made in the current context to the underlying database.
    /// </summary>
    /// <remarks>Before saving, this method updates audit fields for the entities being tracked.  Use this
    /// method to persist changes to the database while ensuring audit information is updated.</remarks>
    /// <returns>The number of state entries written to the database.</returns>
    public override int SaveChanges()
    {
        UpdateAuditFields();
        return base.SaveChanges();
    }

    /// <summary>
    /// Asynchronously saves all changes made in the current context to the database.
    /// </summary>
    /// <remarks>This method updates audit fields before saving changes to ensure that metadata such as
    /// timestamps or user information is recorded.</remarks>
    /// <param name="cancellationToken">A <see cref="CancellationToken"/> that can be used to cancel the asynchronous operation.</param>
    /// <returns>A task that represents the asynchronous save operation. The task result contains the number of state entries
    /// written to the database.</returns>
    public override Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
    {
        UpdateAuditFields();
        return base.SaveChangesAsync(cancellationToken);
    }

    /// <summary>
    /// Updates the audit fields for entities tracked by the change tracker.
    /// </summary>
    /// <remarks>This method iterates through all tracked entities of type <see cref="AuditableEntity"/> and
    /// updates their audit fields based on their state. For entities in the <see cref="EntityState.Added"/> state, it
    /// sets the <see cref="AuditableEntity.CreatedAt"/> and <see cref="AuditableEntity.ModifiedAt"/> fields to the
    /// current UTC time and assigns the namespace of the calling method to <see
    /// cref="AuditableEntity.LastModifiedBy"/>. For entities in the <see cref="EntityState.Modified"/> state, it
    /// updates only the <see cref="AuditableEntity.ModifiedAt"/> and <see cref="AuditableEntity.LastModifiedBy"/>
    /// fields while ensuring the <see cref="AuditableEntity.CreatedAt"/> field remains unchanged.</remarks>
    private void UpdateAuditFields()
    {
        var entries = ChangeTracker.Entries<AuditableEntity>();
        var utcNow = DateTimeOffset.UtcNow;
        var modifiedBy = MethodBase.GetCurrentMethod()?.DeclaringType?.Namespace;

        foreach (var entry in entries)
        {
            if (entry.State == EntityState.Added)
            {
                entry.Entity.LastModifiedBy = modifiedBy;
                entry.Entity.CreatedAt = utcNow;
                entry.Entity.ModifiedAt = utcNow;
            }
            else if (entry.State == EntityState.Modified)
            {
                entry.Property(e => e.CreatedAt).IsModified = false;
                entry.Entity.LastModifiedBy = modifiedBy;
                entry.Entity.ModifiedAt = utcNow;
            }
        }
    }
}
